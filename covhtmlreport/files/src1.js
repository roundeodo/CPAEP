var g_data = {"name":"tb/tb_one_mac_gemm.sv","src":"module tb_one_mac_gemm;\n  //---------------------------\n  // Design Time Parameters\n  //---------------------------\n\n  //---------------------------\n  // DESIGN NOTE:\n  // Parameters are a way to customize your design at\n  // compile time. Here we define the data width,\n  // memory depth, and number of ports for the\n  // multi-port memory instances used in the DUT.\n  //\n  // In other test benches, you can also have test parameters,\n  // such as the number of tests to run, or the sizes of\n  // matrices to be used in the tests.\n  //\n  // You can customize these parameters as needed.\n  // Or you can also add your own parameters.\n  //---------------------------\n\n  // General Parameters\n  parameter int unsigned InDataWidth   = 8;\n  parameter int unsigned OutDataWidth  = 32;\n\n  parameter int unsigned meshRow      = 4;\n  parameter int unsigned meshCol      = 4;\n  parameter int unsigned tileSize     = 4;\n\n  parameter int unsigned SRAM_AB_Width = meshRow * tileSize * InDataWidth; // 128 bits\n  parameter int unsigned SRAM_C_Width  = meshRow * meshCol * OutDataWidth; // 512 bits\n\n\n  parameter int unsigned DataDepth     = 4096;\n  parameter int unsigned AddrWidth     = (DataDepth <= 1) ? 1 : $clog2(DataDepth);\n  parameter int unsigned SizeAddrWidth = 8; // counts blocks now?\n  \n  // Test Parameters\n  parameter int unsigned NumTests = 50;\n\n\n\n\n\n\n  //---------------------------\n  // Wires\n  //---------------------------\n\n  //use for block counting\n  logic [SizeAddrWidth-1:0] M_i, K_i, N_i;\n\n  int unsigned total_row;\n  int unsigned total_col;\n  int unsigned total_k;\n\n  // Clock, reset, and other signals\n  logic clk_i;\n  logic rst_ni;\n  logic start;\n  logic done;\n  \n logic [AddrWidth-1:0] test_depth;\n  //---------------------------\n  // Memory\n  //---------------------------\n  // Memory control\n  logic [AddrWidth-1:0] sram_a_addr;\n  logic [AddrWidth-1:0] sram_b_addr;\n  logic [AddrWidth-1:0] sram_c_addr;\n\n  // Memory access\n  logic signed [ SRAM_AB_Width-1:0] sram_a_rdata;\n  logic signed [ SRAM_AB_Width-1:0] sram_b_rdata;\n  logic signed [SRAM_C_Width-1:0] sram_c_wdata;\n  logic                           sram_c_we;\n\n  // Golden data storage\n  logic signed [SRAM_C_Width-1:0] G_memory [DataDepth];\n\n\n  //---------------------------\n  // Declaration of input and output memories\n  //---------------------------\n  logic signed [InDataWidth-1:0] flat_A [DataDepth];\n  logic signed [InDataWidth-1:0] flat_B [DataDepth];\n  logic signed [OutDataWidth-1:0] flat_C_golden [DataDepth];\n  //---------------------------\n  // DESIGN NOTE:\n  // These are where the memories are instantiated for the DUT.\n  // You can modify the data width and data depth parameters.\n  //\n  // This can be useful for increasing your memory bandwidth.\n  // However, you need to think about and take care of how to,\n  // initialize the memories accordingly.\n  // That includes knowing how to pack the data accordingly.\n  //\n  // Make sure that the connection for the address, data, and wen\n  // signals are consistent with the number of ports.\n  //\n  // Refer to the single_port_memory.sv and \n  // tb_single_port_memory.sv file for more details.\n  //---------------------------\n\n  // Input memory A\n  // Note: this is read only\n  single_port_memory #(\n    .DataWidth     ( SRAM_AB_Width),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_a (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_a_addr  ),\n    .mem_we_i      ( '0           ),\n    .mem_wr_data_i ( '0           ),\n    .mem_rd_data_o ( sram_a_rdata )\n  );\n\n  // Input memory B\n  // Note: this is read only\n  single_port_memory #(\n    .DataWidth     ( SRAM_AB_Width),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_b (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_b_addr  ),\n    .mem_we_i      ( '0           ),\n    .mem_wr_data_i ( '0           ),\n    .mem_rd_data_o ( sram_b_rdata )\n  );\n\n  // Output memory C\n  // Note: this is write only\n  single_port_memory #(\n    .DataWidth     ( SRAM_C_Width ),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_c (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_c_addr  ),\n    .mem_we_i      ( sram_c_we    ),\n    .mem_wr_data_i ( sram_c_wdata ),\n    .mem_rd_data_o ( /* unused */ )\n  );\n\n  //---------------------------\n  // DUT instantiation\n  //---------------------------\n  gemm_accelerator_top #(\n    .InDataWidth   ( InDataWidth   ),\n    .OutDataWidth  ( OutDataWidth  ),\n    .AddrWidth     ( AddrWidth     ),\n    .SizeAddrWidth ( SizeAddrWidth ),\n    .meshRow       ( meshRow       ),\n    .meshCol       ( meshCol       ),\n    .tileSize      ( tileSize      )\n  ) i_dut (\n    .clk_i          ( clk_i        ),\n    .rst_ni         ( rst_ni       ),\n    .start_i        ( start        ),\n    .N_size_i       ( N_i          ),//block count\n    .M_size_i       ( M_i          ),//block count\n    .K_size_i       ( K_i          ),//block count\n    .sram_a_addr_o  ( sram_a_addr  ),\n    .sram_b_addr_o  ( sram_b_addr  ),\n    .sram_c_addr_o  ( sram_c_addr  ),\n    .sram_a_rdata_i ( sram_a_rdata ),\n    .sram_b_rdata_i ( sram_b_rdata ),\n    .sram_c_wdata_o ( sram_c_wdata ),\n    .sram_c_we_o    ( sram_c_we    ),\n    .done_o         ( done         )\n  );\n\n  //---------------------------\n  // Tasks and functions\n  //---------------------------\n  `include \"includes/common_tasks.svh\"\n  `include \"includes/test_tasks.svh\"\n  `include \"includes/test_func.svh\"\n\n  //---------------------------\n  // Test control\n  //---------------------------\n\n  // Clock generation\n  initial begin\n    clk_i = 1'b0;\n    forever #5 clk_i = ~clk_i;  // 100MHz clock\n  end\n\n  \n\n  //initialize memories\n  task init_memories(\n    input int M_blk,\n    input int K_blk,\n    input int N_blk\n    );\n    logic signed [InDataWidth-1:0] temp_val;\n    logic [SRAM_AB_Width-1:0] packed_a;\n    logic [SRAM_AB_Width-1:0] packed_b;\n    int global_r;\n    int global_k;\n    int global_c;\n    //init SRAM A\n    for (int m = 0; m < M_blk; m++) begin\n      for(int k = 0; k < K_blk; k++) begin\n        packed_a = '0;\n\n        //pack 16 bytes \n        for(int r = 0; r < meshRow; r++)begin\n          for(int t = 0; t < tileSize; t++)begin\n          temp_val = $urandom();\n          packed_a[(r*tileSize + t)*InDataWidth +: InDataWidth] = temp_val;  \n          \n          //fill flat A for golden\n          global_r = m*meshRow + r;\n          global_k = k*tileSize + t;\n          flat_A[global_r * total_k + global_k] = temp_val;\n          end\n        end\n        i_sram_a.memory[m*K_blk + k] = packed_a;\n      end\n    end\n\n    //init SRAM B\n    for (int n = 0; n < N_blk; n++) begin\n      for(int k = 0; k < K_blk; k++) begin\n        packed_b = '0;\n        //pack 16 bytes \n        for(int c = 0; c < meshCol; c++)begin\n          for(int t = 0; t < tileSize; t++)begin\n          temp_val = $urandom();\n          packed_b[(c*tileSize + t)*InDataWidth +: InDataWidth] = temp_val;  \n          \n          //fill flat B for golden\n\n          global_c = n*meshCol + c;\n          global_k = k*tileSize + t;\n          flat_B[global_k * total_col + global_c] = temp_val;\n          end\n        end\n        i_sram_b.memory[n*K_blk + k] = packed_b;\n      end\n    end\n  endtask\n\n\n\n\n\n  task verify_result_c(\n    input int M_blk,\n    input int N_blk\n  );\n    int errors;\n    int global_r;\n    int global_c;\n    logic signed [OutDataWidth-1:0] dut_value;\n    logic signed [OutDataWidth-1:0] golden_value;\n    logic [SRAM_C_Width-1:0] c_block;\n    errors = 0;\n\n    for(int m = 0; m < M_blk; m++) begin\n      for(int n = 0; n < N_blk; n++) begin\n        c_block = i_sram_c.memory[m*N_blk + n];\n        for(int r = 0; r < meshRow; r++) begin\n          for(int c = 0; c < meshCol; c++) begin\n            dut_value = c_block[(r*meshCol + c)*OutDataWidth +: OutDataWidth];\n            global_r = m*meshRow + r;\n            global_c = n*meshCol + c;\n            golden_value = flat_C_golden[global_r * total_col + global_c];\n            if (dut_value !== golden_value) begin\n              $display(\"ERROR: Mismatch at C(%0d, %0d): expected %0d, got %0d\",\n                       global_r, global_c, golden_value, dut_value);\n              errors++;\n            end  \n            // else begin\n            //   $display(\"correct: match at C(%0d, %0d): expected %0d, got %0d\",\n            //            global_r, global_c, golden_value, dut_value);\n            // end\n          end\n        end\n      end\n    end\n  endtask\n  //---------------------------\n  // DESIGN NOTE:\n  //\n  // The sequence driver is usually the main stimulus\n  // generator for the test bench. Here is where\n  // you define the sequence of operations to be\n  // performed during the simulation.\n  //\n  // It often starts with an initial reset sequence,\n  // by loading default values and asserting the reset.\n  //\n  // We also do for-loops to run multiple tests\n  // with different input parameters. In this case,\n  // we randomize the matrix sizes for each test.\n  //\n  // You can also customize in here the way\n  // the memories are initialized, how the golden\n  // results are generated, and how the results\n  // are verified.\n  //\n  // Refer to the tasks and functions included above\n  // for more details.\n  //---------------------------\n\n  // Sequence driver\n  initial begin\n\n    // Initial reset\n    start  = 1'b0;\n    rst_ni = 1'b0;\n    #50;\n    rst_ni = 1'b1;\n\n    for (integer num_test = 0; num_test < NumTests; num_test++) begin\n      $display(\"Test number: %0d\", num_test);\n\n      if(num_test == 0) begin\n        //case 1 :4x64 * 64x16\n        M_i = 1; K_i = 1; N_i = 3;\n        $display(\">>CASE1: 4x64 * 64x16\");\n        end\n        else if (num_test == 1) begin\n            // Case 2: 16x64 * 64x4\n            // M=4 Blocks (16 rows), K=16 Blocks (64 depth), N=1 Block (4 cols)\n            M_i = 4; K_i = 16; N_i = 1;\n            $display(\">> Case 2: 16x64 * 64x4\");\n        end        \n        else if (num_test == 2) begin\n            // Case 3: 32x32 * 32x32\n            // M=8 Blocks (32 rows), K=8 Blocks (32 depth), N=8 Blocks (32 cols)\n            M_i = 8; K_i = 8; N_i = 8;\n            $display(\">> Case 3: 32x32 * 32x32\");\n        end \n        else begin\n            // Random Tests (Upper limit: 8 blocks = 32 size)\n            M_i = $urandom_range(1, 16);\n            K_i = $urandom_range(1, 16);\n            N_i = $urandom_range(1, 16);\n            $display(\">> Random Case\");\n        end\n        total_col = N_i * meshCol;\n        total_row = M_i * meshRow;\n        total_k   = K_i * tileSize;\n        $display(\"for test %0d   Block Dimensions: M=%0d, K=%0d, N=%0d\", num_test, M_i, K_i, N_i);\n      //---------------------------\n      // DESIGN NOTE:\n      // You will most likely modify this part\n      // to initialize the input memories\n      // according to your design requirements.\n      //\n      // In here, we simply fill the memories\n      // with random data for testing.\n      //\n      // We assume a row-major storage for both matrices A and B.\n      // Row major means that the elements of each row\n      // are stored in contiguous memory locations.\n      //\n      // We also make the assumption that the matrix output C\n      // will be stored in row-major format as well.\n      //\n      // Take note that you WILL change this part according to your design.\n      // Just make sure that the way you initialize the memories\n      // is consistent with the way you generate the golden results\n      // and the way your DUT reads/writes the data.\n      //\n      // The tricky part here is that since the data accesses are\n      // shared within a single long bit-width (suppose you use longer)\n      // memory word. For example, if your memory word is 32 bits wide\n      // and your data width is 8 bits, then you can pack\n      // 4 data elements in a single memory word.\n      // So when you initialize the memory, you need to\n      // make sure that the data elements are packed\n      // correctly within each memory word.\n      //---------------------------\n      \n      // Initialize input memories and compute golden result\n      init_memories(M_i, K_i, N_i);\n      gemm_golden(total_row, total_k, total_col, flat_A, flat_B, flat_C_golden);\n\n\n      // Just delay 1 cycle\n      clk_delay(1);\n\n      // Execute the GeMM\n      start_and_wait_gemm();\n      \n      clk_delay(5);\n      verify_result_c(M_i, N_i);\n\n      // Just some trailing cycles\n      // For easier monitoring in waveform\n      clk_delay(10);\n    end\n\n    $display(\"All test tasks completed successfully!\");\n    $finish;\n  end\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);