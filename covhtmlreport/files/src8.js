var g_data = {"name":"rtl/common/ceiling_counter.sv","src":"//-----------------------------\n// Ceiling Counter\n//\n// Description:\n// This module implements a ceiling counter that counts up to a specified\n// ceiling value. It supports an optional ceiling limit and provides a\n// signal indicating when the counter has reached its last value.\n//\n// Parameters:\n// - Width      : Width of the counter.\n// - HasCeiling : If set to 1, the counter wraps around at the ceiling\n//                value; if set to 0, it is a free-running counter.\n// Ports:\n// - clk_i        : Clock input.\n// - rst_ni       : Active-low reset input.\n// - tick_i       : Tick input to increment the counter.\n// - clear_i      : Active-high synchronous clear input.\n// - ceiling_i    : Ceiling value input.\n// - count_o      : Current counter value output.\n// - last_value_o : Output signal that is high when the counter reaches\n//                  its last value on a tick.\n//-----------------------------\n\nmodule ceiling_counter #(\n  parameter int Width      = 8,\n  parameter int HasCeiling = 1\n) (\n  input  logic             clk_i,\n  input  logic             rst_ni,       // active-low async reset\n  input  logic             tick_i,       //enable signal\n  input  logic             clear_i,      // active-high sync clear\n  input  logic [Width-1:0] ceiling_i,   //it will be reset when the value reach ceiling\n  output logic [Width-1:0] count_o,\n  output logic             last_value_o // high when count_o reaches ceiling_i - 1\n);\n\n  // Main counter\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      // Asynchronous reset to 0\n      count_o <= '0;\n    end else if (clear_i) begin\n      // Synchronous \"clear\" input\n      count_o <= '0;\n    end else if (tick_i) begin\n      // Only update on tick\n      if (HasCeiling) begin\n        // Compare against (ceiling_i - 1)\n        if (count_o < (ceiling_i - 1'b1))\n          count_o <= count_o + 1'b1;\n        else count_o <= '0;\n      end else begin\n        // Free-running counter\n        count_o <= count_o + 1'b1;\n      end\n    end\n  end\n\n  always_comb begin\n    if (HasCeiling) begin\n      // last_value_o is true if count_o == (ceiling_i - 1) AND a tick occurs\n      last_value_o = (count_o == (ceiling_i - 1'b1)) && tick_i;\n    end else begin\n      // last_value_o is true if all bits of count_o are 1 AND a tick occurs\n      last_value_o = (&count_o) && tick_i;\n    end\n  end\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);