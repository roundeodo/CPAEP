var g_data = {"name":"includes/test_tasks.svh","src":"// Task to start the accelerator\n// and wait for it to finish its task\ntask automatic start_and_wait_gemm();\nbegin\n  automatic int cycle_count;\n  cycle_count = 0;\n  // Start the GEMM operation\n  @(posedge clk_i);\n  start = 1'b1;\n  @(posedge clk_i);\n  start = 1'b0;\n  while (done == 1'b0) begin\n  @(posedge clk_i);\n  cycle_count = cycle_count + 1;\n  if (cycle_count > 100000) begin\n    $display(\"ERROR: GEMM operation timeout after %0d cycles\", cycle_count);\n    $fatal;\n  end\n  end\n  @(posedge clk_i);\n  $display(\"GEMM operation completed in %0d cycles\", cycle_count);\nend\nendtask\n\n// Task to verify the resulting matrix\n// task automatic verify_result_c(\n//   input logic signed [OutDataWidth-1:0] golden_data [DataDepth],\n//   input logic signed [OutDataWidth-1:0] actual_data [DataDepth],\n//   input logic        [   AddrWidth-1:0] num_data,\n//   input logic                           fatal_on_mismatch\n// );\n// begin\n//     // Compare with SRAM C contents\n//   for (int unsigned addr = 0; addr < num_data; addr++) begin\n//   if (golden_data[addr] !== actual_data[addr]) begin\n//     $display(\"ERROR: Mismatch at address %0d: expected %h, got %h\",\n//             addr, golden_data[addr], actual_data[addr]);\n//     if (fatal_on_mismatch)\n//     $fatal;\n//   end\n//   end\n//   $display(\"Result matrix C verification passed!\");\n// end\n// endtask\n\n\n  // task compute_golden(\n  //   input int M_blk,\n  //   input int K_blk,\n  //   input int N_blk\n  // );\n  //   logic signed [InDataWidth-1:0] val_a;\n  //   logic signed [InDataWidth-1:0] val_b;\n  //   logic signed [OutDataWidth-1:0] sum;\n  //   logic [SRAM_C_Width-1:0] pack_c;\n    \n  //   //output c\n  //   for(int m = 0; m <M_blk; m = m + 1)begin\n  //     for(int n = 0; n <N_blk; n = n + 1)begin\n  //       //calculate one C block\n  //       pack_c = '0;\n  //       for(int r = 0; r < meshRow; r = r + 1)begin\n  //         for(int c = 0; c < meshCol; c = c + 1)begin\n  //           sum = 0;\n\n  //           //dot product over K blocks\n  //           for(int k = 0; k < K_blk; k = k + 1)begin\n  //             //dot product inside the block\n  //             for(int t = 0; t < tileSize; t = t + 1)begin\n  //               //unpacked A\n  //               val_a = i_sram_a.memory[m*K_blk + k][(r*tileSize + t)*InDataWidth +: InDataWidth];\n  //               //unpacked B\n  //               val_b = i_sram_b.memory[n*K_blk + k][(c*tileSize + t)*InDataWidth +: InDataWidth];\n  //               sum = $signed(sum) + ($signed(val_a) * $signed(val_b));\n  //             end\n  //           end\n  //           //pack result into 512-bit vector\n  //           pack_c[(r*meshCol + c)*OutDataWidth +: OutDataWidth] = sum;\n  //         end\n  //       end\n  //       G_memory[m*N_blk + n] = pack_c;\n  //     end\n  //   end\n\n  // endtask\n\n","lang":"verilog"};
processSrcData(g_data);