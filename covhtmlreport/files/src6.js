var g_data = {"name":"rtl/gemm/gemm_accelerator_top.sv","src":"//---------------------------\n// The 64-MAC GeMM accelerator top module\n//\n// Description:\n// This module implements a simple General Matrix-Matrix Multiplication (GeMM)\n// accelerator using a 64 Multiply-Accumulate (MAC) Processing Elements (PEs).\n// It interfaces with three SRAMs for input matrices A and B, and output matrix C.\n//\n// It includes a controller to manage the GeMM operation and address generation logic\n// for accessing the SRAMs based on the current matrix sizes and counters.\n//\n// Parameters:\n// - InDataWidth  : Width of the input data (matrix elements).\n// - OutDataWidth : Width of the output data (result matrix elements).\n// - AddrWidth    : Width of the address bus for SRAMs.\n// - SizeAddrWidth: Width of the size parameters for matrices.\n//\n// Ports:\n// - clk_i        : Clock input.\n// - rst_ni       : Active-low reset input.\n// - start_i      : Start signal to initiate the GeMM operation.\n// - M_size_i     : block nums of matrix M (number of M_blocks in A and C).\n// - K_size_i     : block nums of matrix K (number of K_blocks in A and B).\n// - N_size_i     : block nums of matrix N (number of N_blocks in B and C).\n// - sram_a_addr_o: Address output for SRAM A.\n// - sram_b_addr_o: Address output for SRAM B.\n// - sram_c_addr_o: Address output for SRAM C.\n// - sram_a_rdata_i: Data input from SRAM A.\n// - sram_b_rdata_i: Data input from SRAM B.\n// - sram_c_wdata_o: Data output to SRAM C.\n// - sram_c_we_o  : Write enable output for SRAM C.\n// - done_o       : Done signal indicating completion of the GeMM operation.\n//---------------------------\n\nmodule gemm_accelerator_top #(\n  parameter int unsigned InDataWidth = 8,\n  parameter int unsigned OutDataWidth = 32,\n  parameter int unsigned AddrWidth = 16,\n  parameter int unsigned SizeAddrWidth = 8,\n  parameter int unsigned meshRow = 2,\n  parameter int unsigned meshCol = 2,\n  parameter int unsigned tileSize = 16\n) (\n  input  logic                            clk_i,\n  input  logic                            rst_ni,\n  input  logic                            start_i,\n\n  input  logic        [SizeAddrWidth-1:0] M_size_i,\n  input  logic        [SizeAddrWidth-1:0] K_size_i,\n  input  logic        [SizeAddrWidth-1:0] N_size_i,\n\n  output logic        [    AddrWidth-1:0] sram_a_addr_o,\n  output logic        [    AddrWidth-1:0] sram_b_addr_o,\n  output logic        [    AddrWidth-1:0] sram_c_addr_o,\n\n  input  logic signed [  meshRow * tileSize * InDataWidth-1:0] sram_a_rdata_i,\n  input  logic signed [  meshCol * tileSize * InDataWidth-1:0] sram_b_rdata_i,\n\n  output logic signed [ meshRow * meshCol * OutDataWidth-1:0] sram_c_wdata_o,\n\n  output logic                            sram_c_we_o,\n  output logic                            done_o\n);\n\n  //---------------------------\n  // Wires\n  //---------------------------\n  logic [SizeAddrWidth-1:0] M_count;\n  logic [SizeAddrWidth-1:0] K_count;\n  logic [SizeAddrWidth-1:0] N_count;\n  logic [SizeAddrWidth-1:0] M_count_write;\n  logic [SizeAddrWidth-1:0] N_count_write;\n\n  logic busy;\n  logic valid_data;\n  assign valid_data = start_i || busy;  // Always valid in this simple design\n\n  logic init_save_ctrl; //from controller to mac array\n  logic result_valid_ctrl; //from controller to WE logic\n  assign sram_c_we_o = result_valid_ctrl;\n  //---------------------------\n  // DESIGN NOTE:\n  // This is a simple GeMM accelerator design using a 64 MAC PE.\n  // The controller manages just the counting capabilities.\n  // Check the gemm_controller.sv file for more details.\n  //\n  // Essentially, it tightly couples the counters and an FSM together.\n  // The address generation logic is just after this controller.\n  //\n  // You have the option to combine the address generation and controller\n  // all in one module if you prefer. We did this intentionally to separate tasks.\n  //---------------------------\n\n  // Main GeMM controller\n  gemm_controller #(\n    .AddrWidth      ( SizeAddrWidth )\n  ) i_gemm_controller (\n    .clk_i          ( clk_i       ),\n    .rst_ni         ( rst_ni      ),\n    .start_i        ( start_i     ),\n    .input_valid_i  ( 1'b1        ),  // Always valid in this simple design\n    .init_save_o    ( init_save_ctrl ),\n    .result_valid_o ( result_valid_ctrl ),\n    .busy_o         ( busy        ),\n    .done_o         ( done_o      ),\n    //the block size of M, K, N\n    .M_size_i       ( M_size_i    ),\n    .K_size_i       ( K_size_i    ),\n    .N_size_i       ( N_size_i    ),\n    //the block indices of M, K, N\n    .M_count_o      ( M_count     ),\n    .K_count_o      ( K_count     ),\n    .N_count_o      ( N_count     ),\n    .M_count_write_o( M_count_write),\n    .N_count_write_o( N_count_write)\n  );\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the address generation logic for the input and output SRAMs.\n  // A B C are in block-base layout\n  //formula:\n  // global_block_index = outer_count * total_inner_blocks + inner_count\n\n  //---------------------------\n\n  // Input addresses for matrices A and B\n  // matrix A: row major of blocks [M_block][K_block]\n  //  address_A = M_count * K_size_i + K_count\n  assign sram_a_addr_o = (M_count * K_size_i + K_count);\n  \n  // matrix B: column major of blocks [N_block][K_block]\n  //  address_B = N_count * K_size_i + K_count\n  assign sram_b_addr_o = (N_count * K_size_i + K_count);\n\n  // matrix C :row-major of blocks [M_block][N_block]\n  //  address_C = M_count * N_size_i + N_count\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      sram_c_addr_o <= '0;\n    end else if (1'b1) begin  // Always valid in this simple design\n      sram_c_addr_o <= (M_count * N_size_i + N_count);\n    end\n  end\n  //assign sram_c_addr_o = (M_count_write * N_size_i + N_count_write);\n\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the MAC PE instantiation and data path logic.\n  // However, you can expand this part to support multiple PEs\n  // by adjusting the data widths and input/output connections accordingly.\n  //\n  // Systemverilog has a useful mechanism to generate multiple instances\n  // using generate-for loops.\n  // Below is an example of a 2D generate-for loop to create a grid of PEs.\n  //\n  // ----------- BEGIN CODE EXAMPLE -----------\n  // genvar m, k, n;\n  //\n  //   for (m = 0; m < M; m++) begin : gem_mac_pe_m\n  //     for (n = 0; n < N; n++) begin : gem_mac_pe_n\n  //         mac_module #(\n  //           < insert parameters >\n  //         ) i_mac_pe (\n  //           < insert port connections >\n  //         );\n  //     end\n  //   end\n  // ----------- END CODE EXAMPLE -----------\n  // \n  // There are many guides on the internet (or even ChatGPT) about generate-for loops.\n  // We will give it as an exercise to you to modify this part to support multiple MAC PEs.\n  // \n  // When dealing with multiple PEs, be careful with the connection alignment\n  // across different PEs as it can be tricky to debug later on.\n  // Plan this very carefully, especially when delaing with the correcet data ports\n  // data widths, slicing, valid signals, and so much more.\n  //\n  // Additionally, this MAC PE is already output stationary.\n  // You have the freedom to change the dataflow as you see fit.\n  //---------------------------\n\n  // The MAC PE instantiation and data path logics\n\n  //DATA reshaping for MAC array\n  //SRAM provide 1D vectors but the MAC array needs 3D arrays\n\n  //A_reshaped\n  logic signed [meshRow-1:0][tileSize-1:0][InDataWidth-1:0] a_data_reshaped;\n  always_comb begin\n    for(int r = 0; r < meshRow; r = r + 1) begin\n      for(int t = 0; t < tileSize; t = t + 1) begin\n        a_data_reshaped[r][t] = sram_a_rdata_i[(r*tileSize + t)*InDataWidth +: InDataWidth];\n      end\n    end\n  end\n\n  //B_reshaped\n  logic signed [meshCol-1:0][tileSize-1:0][InDataWidth-1:0] b_data_reshaped;\n  always_comb begin\n    for(int c = 0; c < meshCol; c = c + 1) begin\n      for(int t = 0; t < tileSize; t = t + 1) begin\n        b_data_reshaped[c][t] = sram_b_rdata_i[(c*tileSize + t)*InDataWidth +: InDataWidth];\n      end\n    end\n  end\n\n  //C_reshaped\n  logic signed [meshRow-1:0][meshCol-1:0][OutDataWidth-1:0] c_data_reshaped;\n  always_comb begin\n    for(int r = 0; r < meshRow; r = r + 1) begin\n      for(int c = 0; c < meshCol; c = c + 1) begin\n        sram_c_wdata_o[(r*meshCol + c)*OutDataWidth +: OutDataWidth] = c_data_reshaped[r][c];\n      end\n    end\n  end\n\n  mac_array_3D_444 #(\n    .InDataWidth  ( InDataWidth  ),\n    .OutDataWidth ( OutDataWidth ),\n    .meshRow      ( meshRow      ),\n    .meshCol      ( meshCol      ),\n    .tileSize     ( tileSize     )\n  ) i_mac_array (\n    .clk_i        ( clk_i               ),\n    .rst_ni       ( rst_ni              ),\n    .a_i          ( a_data_reshaped     ),\n    .b_i          ( b_data_reshaped     ),\n    .a_valid_i    ( valid_data          ),\n    .b_valid_i    ( valid_data          ),\n    .init_save_i  ( init_save_ctrl      ),\n    .acc_clr_i    (!busy                ), //clear when not busy\n    .c_o          ( c_data_reshaped     )\n  );\n\n\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);